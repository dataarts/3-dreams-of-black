<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js - geometry - marching cubes - webgl</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				color: #fff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

		</style>
	</head>
	<body>

		<script type="text/javascript" src="js/Three.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>


		<script type="text/javascript">

			var container, stats;
			var camera, sceneCollision, sceneVoxels, sceneBlob, renderer;
			var mesh, texture, geometry, material;

			var marchingcubes, resolution = 32, grid = 32, blob, blobMaterial;
			var voxel_size = 50, voxel_geometry, voxel_material, voxels = [];

			var plane, projector, mouse2D, mouse3D, ray;

			var shadowCamera, shadowPlane, shadowTexture, shadowMaterial;

			var isCtrlDown = false, isShiftDown = false,
			isMouseDown = false, radius = 1500, theta = 45;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<strong>click + drag</strong>: draw, <strong>control + click & drag</strong>: erase, <strong>shift</strong>: rotate';
				container.appendChild( info );

				camera = new THREE.Camera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 500;

				sceneCollision = new THREE.Scene();
				sceneVoxels = new THREE.Scene();
				sceneBlob = new THREE.Scene();

				sceneBlob.addLight( new THREE.AmbientLight( 0x404050 ) );

				/*
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0.5, 0.5, 1 );
				light.position.normalize();
				sceneBlob.addLight( light );
				*/

				var pointLight = new THREE.PointLight( 0xffffff );
				pointLight.position.set( 0, 0, 1000 );
				sceneBlob.addLight( pointLight );

				var pointLight = new THREE.PointLight( 0xffffff, 2 );
				pointLight.color.setHSV( 0.05, 1.0, 0.5 );
				pointLight.position.set( 0, 0, - 1000 );
				sceneBlob.addLight( pointLight );

				//

				var geometry = new Plane( 2000, 2000, 16, 16 ),
				material = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.1, wireframe: true } );

				plane = new THREE.Mesh( geometry, material );
				// plane.rotation.x = - 90 * Math.PI / 180;
				plane.doubleSided = true;
				plane.matrixAutoUpdate = false;
				sceneCollision.addObject( plane );

				//

				projector = new THREE.Projector();

				mouse2D = new THREE.Vector3( 0, 0, 0.5 );
				ray = new THREE.Ray( camera.position, null );

				blobMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, opacity: 0.5, transparent: true, depthTest: false, shading: THREE.FlatShading } );

				marchingcubes = new THREE.MarchingCubes( resolution, blobMaterial );
				marchingcubes.isolation = 40;
				marchingcubes.scale.x = marchingcubes.scale.y = marchingcubes.scale.z = 800;
				sceneBlob.addObject( marchingcubes );

				//

				voxel_geometry = new Cube( 50, 50, 50 );
				voxel_material = material;


				// Shadow

				shadowCamera = new THREE.Camera( 100, 1, 1, 5000 );
				shadowCamera.position.y = 1000;

				shadowTexture = new THREE.WebGLRenderTarget( 128, 128 );

				shadowPlane = new THREE.Mesh( new Plane( 3000, 3000 ), new THREE.MeshBasicMaterial( { map: shadowTexture } ) );
				shadowPlane.position.y = - 500;
				shadowPlane.rotation.x = - 90 * Math.PI / 180;
				shadowPlane.rotation.z = - 90 * Math.PI / 180;
				shadowPlane.scale.x = - 1;
				shadowPlane.flipSided = true;
				sceneBlob.addObject( shadowPlane );

				shadowMaterial = new THREE.MeshBasicMaterial( { color: 0xC0C0C0 } );


				//

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColorHex( 0xffffff );
				renderer.autoClear = false;
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

			}

			function onDocumentKeyDown( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = true; break;
					case 17: isCtrlDown = true; break;
					case 18: isCtrlDown = true; break;

				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;
					case 17: isCtrlDown = false; break;
					case 18: isCtrlDown = false; break;

				}
			}

			function onDocumentMouseMove(event) {

				mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				var mouse3D = projector.unprojectVector( mouse2D.clone(), camera );
				ray.direction = mouse3D.subSelf( camera.position ).normalize();

				if ( isMouseDown ) {

					draw();

				} else {

					var intersects = ray.intersectScene( sceneVoxels );

					if ( intersects.length > 0 ) {

						var point = intersects[ 0 ].point.clone().addSelf( intersects[ 0 ].face.normal.clone().multiplyScalar( 25 ) );

						plane.position.copy( point );
						plane.lookAt( camera.position );
						// plane.position.copy( point );
						plane.updateMatrix();
						plane.update();


					}

				}

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();
				event.stopPropagation();

				isMouseDown = true;

			}

			function onDocumentMouseUp( event ) {

				event.preventDefault();
				event.stopPropagation();

				isMouseDown = false;

			}

			function onDocumentMouseWheel( event ) {
 
				radius -= event.wheelDeltaY;
 
			}

			function draw() {

				var intersects;

				if ( isCtrlDown ) {

					intersects = ray.intersectScene( sceneVoxels );

					if ( intersects.length > 0 ) {

						sceneVoxels.removeObject( intersects[ 0 ].object );

						for ( var i = 0, il = voxels.length; i < il; i ++ ) {

							if ( voxels[ i ] == intersects[ 0 ].object ) {

								voxels.splice( i, 1 );
								updateBlob();
								return;

							}

						}

					}

				} else {

					intersects = ray.intersectScene( sceneCollision );

					if ( intersects.length > 0 ) {

						var position = new THREE.Vector3().add( intersects[ 0 ].point, intersects[ 0 ].object.matrixRotationWorld.multiplyVector3( intersects[ 0 ].face.normal.clone() ) );

						addVoxel( position );

					}

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				loop();

				stats.update();

			}

			function loop() {

				if ( isShiftDown ) {

					theta += mouse2D.x * 3;

				}

				camera.position.x = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );

				// camera.position.x += ( mouse2D.x * 500 - camera.position.x ) * .01;
				// camera.position.y += ( - mouse2D.y * 500 - camera.position.y ) * .01;

				// testSetup();
				// createBlob();

				renderer.clear();

				marchingcubes.materials[ 0 ] = shadowMaterial;
				shadowPlane.visible = false;

				renderer.render( sceneBlob, shadowCamera, shadowTexture, true );

				marchingcubes.materials[ 0 ] = blobMaterial;
				shadowPlane.visible = true;

				renderer.render( sceneBlob, camera );
				renderer.render( sceneVoxels, camera );
				renderer.render( sceneCollision, camera );

			}

			function addVoxel( position ) {

				voxel = new THREE.Mesh( voxel_geometry, voxel_material );
				voxel.position.x = Math.round( position.x / voxel_size ) * voxel_size;
				voxel.position.y = Math.round( position.y / voxel_size ) * voxel_size;
				voxel.position.z = Math.round( position.z / voxel_size ) * voxel_size;
				voxel.matrixAutoUpdate = false;
				voxel.updateMatrix();
				voxel.update();
				sceneVoxels.addObject( voxel );

				voxels.push( voxel );

				updateBlob();

			}

			function updateBlob() {

				marchingcubes.reset();

				var voxel, x, y, z;

				for ( var i = 0, il = voxels.length; i < il; i ++ ) {

					voxel = voxels[ i ];
					x = ( voxel.position.x / voxel_size / grid ) + 0.5;
					y = ( voxel.position.y / voxel_size / grid ) + 0.5;
					z = ( voxel.position.z / voxel_size / grid ) + 0.5;

					marchingcubes.addBall( x, y, z, 0.02, 10 );

				}

			}

			function testSetup() {

				marchingcubes.reset();

				var step = 4;

				for ( var x = step; x < grid; x += step ) {

					for ( var y = step; y < grid; y += step ) {

						for ( var z = step; z < grid; z += step ) {

							marchingcubes.addBall( x / grid, y / grid, z / grid, 0.2, 10 );

						}

					}

				}

			}

		</script>

	</body>
</html>
